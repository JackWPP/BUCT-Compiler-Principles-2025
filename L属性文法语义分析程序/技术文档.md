# L属性文法语义分析程序 - 技术文档

## 1. 系统架构

### 1.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                    L属性文法语义分析程序                      │
├─────────────────────────────────────────────────────────────┤
│                      用户界面层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│  │ 文法输入界面 │ │ 分析过程界面 │ │ 符号表界面   │ │ 帮助界面 │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      业务逻辑层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐            │
│  │ 文法解析器   │ │ 语义分析引擎 │ │ 符号表管理器 │            │
│  └─────────────┘ └─────────────┘ └─────────────┘            │
├─────────────────────────────────────────────────────────────┤
│                      数据模型层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│  │ L属性文法   │ │ 产生式      │ │ 语义规则     │ │ 符号表   │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心模块

#### 1.2.1 数据模型层
- **L属性文法类** (`L属性文法`): 文法的完整表示
- **文法符号类** (`文法符号`): 终结符和非终结符的统一表示
- **产生式类** (`产生式`): 产生式的结构化存储
- **属性定义类** (`属性定义`): 属性的类型和特性定义
- **语义规则类** (`语义规则`): 语义动作的表示
- **符号表类** (`符号表`): 标识符信息管理

#### 1.2.2 业务逻辑层
- **文法解析器** (`L属性文法解析器`): 解析文法定义文件
- **语义分析引擎** (`语义分析引擎`): 执行语义分析
- **符号表管理器**: 管理符号表的增删改查

#### 1.2.3 用户界面层
- **主界面** (`L属性文法分析器GUI`): 多标签页界面
- **文法输入界面**: 文法定义和编辑
- **分析过程界面**: 语义分析过程展示
- **符号表界面**: 符号表管理和查看

## 2. 核心算法

### 2.1 L属性文法解析算法

```python
def 解析文法文件(self, 文件内容: str) -> Tuple[bool, L属性文法, List[str]]:
    """
    解析L属性文法文件的核心算法
    
    算法步骤：
    1. 按行分割文件内容
    2. 识别模式标记 ([文法], [属性定义], [语义规则])
    3. 根据当前模式解析相应内容
    4. 构建文法对象
    5. 验证L属性特性
    """
```

### 2.2 L属性特性验证算法

```python
def 验证L属性特性(self) -> Tuple[bool, List[str]]:
    """
    验证文法是否满足L属性特性
    
    L属性特性定义：
    对于产生式 A -> X1 X2 ... Xn 中的每个符号 Xi：
    - Xi 的继承属性只能依赖于：
      * Xi 左边符号 X1, X2, ..., Xi-1 的属性
      * A 的继承属性
    - 不能依赖于 Xi 右边符号的属性
    """
```

### 2.3 属性计算算法

```python
def _计算表达式(self, 表达式: str, 产生式: 产生式) -> Any:
    """
    计算语义表达式的值
    
    算法步骤：
    1. 识别表达式中的属性引用
    2. 替换属性引用为实际值
    3. 处理特殊函数调用 (addtype, newtemp等)
    4. 计算最终结果
    """
```

## 3. 数据结构设计

### 3.1 核心数据结构

#### 3.1.1 属性定义
```python
@dataclass
class 属性定义:
    名称: str                    # 属性名称
    类型: 属性类型               # 综合属性/继承属性
    数据类型: str = "字符串"     # 数据类型
    默认值: Any = None           # 默认值
    描述: str = ""               # 属性描述
```

#### 3.1.2 产生式
```python
@dataclass
class 产生式:
    左部: str                    # 产生式左部
    右部: List[str]              # 产生式右部
    语义规则: List[str] = field(default_factory=list)
    编号: int = 0                # 产生式编号
```

#### 3.1.3 语义规则
```python
@dataclass
class 语义规则:
    目标属性: str                # 目标属性
    表达式: str                  # 计算表达式
    依赖属性: List[str] = field(default_factory=list)
    动作类型: str = "赋值"       # 动作类型
```

### 3.2 符号表设计

#### 3.2.1 符号表项
```python
@dataclass
class 符号表项:
    名称: str                    # 标识符名称
    类型: str = ""               # 标识符类型
    值: Any = None               # 标识符值
    作用域: str = "全局"         # 作用域
    行号: int = 0                # 定义行号
    其他信息: Dict[str, Any] = field(default_factory=dict)
```

#### 3.2.2 符号表管理
```python
class 符号表:
    def __init__(self):
        self.表项: Dict[str, 符号表项] = {}
        self.作用域栈: List[str] = ["全局"]
    
    def 进入作用域(self, 作用域名: str): ...
    def 退出作用域(self): ...
    def 添加符号(self, 符号: 符号表项): ...
    def 查找符号(self, 名称: str) -> Optional[符号表项]: ...
```

## 4. 文法定义格式

### 4.1 文件格式规范

L属性文法定义文件采用分段式格式：

```
# 注释行以#开头

[文法]
# 产生式定义，支持多候选式
左部 -> 右部1 | 右部2 | ...
# 空产生式用ε表示
A -> ε

[属性定义]
# 格式：符号.属性名 : 属性类型 数据类型 默认值 描述
符号.属性名 : 综合|继承 数据类型 默认值 "描述"

[语义规则]
# 格式：目标属性 := 表达式
目标属性 := 表达式
# 支持函数调用
addtype(参数1, 参数2)
```

### 4.2 示例文法

```
[文法]
D -> T L
T -> int | float | char | string
L -> L , id | id

[属性定义]
T.type : 综合 字符串 "" "类型信息"
L.in : 继承 字符串 "" "继承的类型信息"
id.name : 综合 字符串 "" "标识符名称"

[语义规则]
# 产生式 D -> T L
L.in := T.type

# 产生式 T -> int
T.type := "int"

# 产生式 L -> L1 , id
L1.in := L.in
addtype(id.name, L.in)

# 产生式 L -> id
addtype(id.name, L.in)
```

## 5. 语义动作支持

### 5.1 内置函数

#### 5.1.1 addtype函数
```python
def addtype(标识符名: str, 类型: str) -> str:
    """
    将标识符及其类型添加到符号表
    参数：
        标识符名: 要添加的标识符名称
        类型: 标识符的类型
    返回：操作结果描述
    """
```

#### 5.1.2 newtemp函数
```python
def newtemp() -> str:
    """
    生成新的临时变量名
    返回：临时变量名（如t1, t2, ...）
    """
```

### 5.2 表达式计算

支持的表达式类型：
- **字符串连接**: `str1 + str2`
- **数值计算**: `num1 + num2`, `num1 * num2`
- **属性引用**: `符号.属性名`
- **函数调用**: `函数名(参数列表)`
- **常量**: 字符串常量、数值常量

## 6. 错误处理机制

### 6.1 错误类型

1. **语法错误**: 文法定义格式错误
2. **语义错误**: L属性特性违反
3. **运行时错误**: 属性计算错误
4. **系统错误**: 文件操作错误

### 6.2 错误恢复策略

1. **错误检测**: 在每个处理阶段进行错误检查
2. **错误报告**: 提供详细的错误位置和原因
3. **错误恢复**: 尽可能继续处理后续内容
4. **用户提示**: 给出修复建议

## 7. 性能优化

### 7.1 数据结构优化

- 使用字典进行快速符号查找
- 采用栈结构管理作用域
- 缓存计算结果避免重复计算

### 7.2 算法优化

- 预编译正则表达式
- 批量处理属性计算
- 延迟加载大型数据结构

### 7.3 内存管理

- 及时清理临时数据
- 使用生成器减少内存占用
- 合理使用数据类减少内存开销

## 8. 扩展性设计

### 8.1 插件化架构

- 语义动作可通过插件扩展
- 支持自定义函数注册
- 可扩展的文法格式解析器

### 8.2 接口设计

- 标准化的API接口
- 事件驱动的处理机制
- 可配置的处理参数

### 8.3 国际化支持

- 分离界面文本和逻辑代码
- 支持多语言错误信息
- 可配置的界面语言

## 9. 测试策略

### 9.1 单元测试

- 每个核心类都有对应的测试用例
- 覆盖正常情况和异常情况
- 使用断言验证结果正确性

### 9.2 集成测试

- 测试完整的分析流程
- 验证模块间的协作
- 检查数据传递的正确性

### 9.3 用户界面测试

- 测试GUI组件的交互
- 验证用户操作的响应
- 检查界面显示的正确性

## 10. 部署和维护

### 10.1 部署要求

- Python 3.7+ 环境
- tkinter GUI库支持
- 足够的系统内存和磁盘空间

### 10.2 打包发布

- 使用PyInstaller打包为可执行文件
- 包含所有必要的依赖库
- 提供安装和使用说明

### 10.3 维护策略

- 定期更新文档
- 收集用户反馈
- 持续改进功能和性能
