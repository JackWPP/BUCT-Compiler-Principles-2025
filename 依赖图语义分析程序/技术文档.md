# 依赖图语义分析程序 - 技术文档

## 1. 项目概述

### 1.1 项目背景
依赖图语义分析程序是编译原理课程的实践项目，实现了基于依赖图的语义分析方法。该方法是属性文法语义分析的一种通用实现，能够处理比L属性文法更复杂的属性依赖关系。

### 1.2 技术特点
- **通用性强**：不限于L属性特性，支持任意属性依赖关系
- **算法完整**：包含依赖图构建、循环检测、拓扑排序等核心算法
- **可视化支持**：提供依赖图的图形化展示
- **错误检测**：完善的错误检测和报告机制
- **中文界面**：全中文用户界面和文档

## 2. 系统架构

### 2.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                      用户界面层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│  │ 文法输入    │ │ 依赖图构建   │ │ 语义分析     │ │ 可视化   │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      业务逻辑层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│  │ 文法解析器   │ │ 依赖图构建器 │ │ 语义分析引擎 │ │ 可视化器 │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      数据模型层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│  │ 属性文法    │ │ 依赖图      │ │ 语义规则     │ │ 分析步骤 │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心模块

#### 2.2.1 数据模型层
- **属性文法类** (`属性文法`): 文法的完整表示
- **文法符号类** (`文法符号`): 终结符和非终结符的统一表示
- **产生式类** (`产生式`): 产生式的结构化存储
- **属性定义类** (`属性定义`): 属性的类型和特性定义
- **语义规则类** (`语义规则`): 语义动作的表示
- **依赖图类** (`依赖图`): 属性依赖关系的图表示
- **依赖图节点类** (`依赖图节点`): 依赖图中的节点

#### 2.2.2 业务逻辑层
- **文法解析器** (`属性文法解析器`): 解析文法定义文件
- **依赖图构建器** (`依赖图构建器`): 构建属性依赖图
- **语义分析引擎** (`语义分析引擎`): 执行语义分析

#### 2.2.3 用户界面层
- **主界面** (`依赖图语义分析器GUI`): 多标签页界面
- **文法输入界面**: 文法定义和编辑
- **依赖图构建界面**: 依赖图构建和信息展示
- **分析过程界面**: 语义分析过程展示
- **可视化界面**: 依赖图的图形化展示

## 3. 核心算法

### 3.1 依赖图构建算法

```python
def 构建依赖图(self, 语法分析树: List[int]) -> Tuple[bool, 依赖图, str]:
    """
    依赖图构建算法
    
    算法步骤：
    1. 模拟语法分析过程，为每个符号实例创建属性节点
    2. 根据语义规则建立属性之间的依赖关系
    3. 构建有向图表示依赖关系
    4. 返回完整的依赖图
    """
```

### 3.2 循环依赖检测算法

```python
def 检测循环依赖(self) -> Tuple[bool, List[str]]:
    """
    循环依赖检测算法（基于DFS）
    
    算法原理：
    - 使用三色标记法（白色、灰色、黑色）
    - 白色：未访问的节点
    - 灰色：正在访问的节点（在当前DFS路径中）
    - 黑色：已完成访问的节点
    - 如果在DFS过程中遇到灰色节点，说明存在循环
    """
```

### 3.3 拓扑排序算法

```python
def 拓扑排序(self) -> Tuple[bool, List[str], str]:
    """
    拓扑排序算法（Kahn算法）
    
    算法步骤：
    1. 计算每个节点的入度
    2. 将入度为0的节点加入队列
    3. 重复以下步骤直到队列为空：
       - 从队列中取出一个节点
       - 将该节点加入结果序列
       - 更新其邻接节点的入度
       - 将新的入度为0的节点加入队列
    4. 如果结果序列长度等于节点总数，则排序成功
    """
```

## 4. 数据结构设计

### 4.1 核心数据结构

#### 4.1.1 属性定义
```python
@dataclass
class 属性定义:
    名称: str                    # 属性名称
    类型: 属性类型               # 综合属性/继承属性
    数据类型: str = "字符串"     # 数据类型
    默认值: Any = None           # 默认值
    描述: str = ""               # 属性描述
```

#### 4.1.2 依赖图节点
```python
@dataclass
class 依赖图节点:
    节点ID: str                  # 节点唯一标识
    属性名: str                  # 属性名称（如 E.val）
    节点类型: str = "属性节点"   # 节点类型
    属性值: Any = None           # 属性值
    已计算: bool = False         # 是否已计算
    计算表达式: str = ""         # 计算表达式
    依赖节点: List[str] = field(default_factory=list)
```

#### 4.1.3 依赖图
```python
class 依赖图:
    节点表: Dict[str, 依赖图节点]              # 节点ID -> 节点对象
    邻接表: Dict[str, List[str]]              # 依赖关系
    反向邻接表: Dict[str, List[str]]          # 反向依赖
    计算顺序: List[str]                       # 拓扑排序结果
```

## 5. 文法格式规范

### 5.1 文法定义格式

属性文法包含三个主要部分：

#### 5.1.1 文法部分
```
[文法]
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```

#### 5.1.2 属性定义部分
```
[属性定义]
E.val : 综合属性
T.val : 综合属性
F.val : 综合属性
id.lexval : 综合属性
```

#### 5.1.3 语义规则部分
```
[语义规则]
E.val := E.val + T.val  # 0
E.val := T.val          # 1
T.val := T.val * F.val  # 2
T.val := F.val          # 3
F.val := E.val          # 4
F.val := id.lexval      # 5
```

### 5.2 语法规则

1. **注释**：以 `#` 开头的行为注释
2. **模式标记**：用 `[模式名]` 标记不同部分
3. **产生式**：使用 `->` 分隔左部和右部，用 `|` 分隔候选
4. **属性定义**：格式为 `符号名.属性名 : 属性类型`
5. **语义规则**：格式为 `目标属性 := 表达式 # 产生式编号`

## 6. 算法复杂度分析

### 6.1 时间复杂度
- **文法解析**：O(n)，其中n为文法文件行数
- **依赖图构建**：O(m×k)，其中m为产生式数量，k为平均属性数量
- **循环检测**：O(V+E)，其中V为节点数，E为边数
- **拓扑排序**：O(V+E)
- **语义分析**：O(V+E)

### 6.2 空间复杂度
- **文法存储**：O(n)，其中n为符号和规则总数
- **依赖图存储**：O(V+E)，其中V为节点数，E为边数
- **分析过程**：O(V)，用于存储分析步骤

## 7. 性能优化

### 7.1 已实现的优化
1. **邻接表表示**：使用邻接表而非邻接矩阵存储图
2. **懒加载**：按需创建和计算属性节点
3. **缓存机制**：缓存拓扑排序结果
4. **智能匹配**：语义规则的智能分配

### 7.2 可能的改进
1. **并行计算**：独立属性的并行计算
2. **增量更新**：文法修改时的增量重构
3. **内存优化**：大规模文法的内存管理

## 8. 错误处理机制

### 8.1 错误类型
1. **语法错误**：文法格式不正确
2. **语义错误**：属性依赖不合理
3. **循环依赖**：属性之间存在循环依赖
4. **运行时错误**：计算过程中的异常

### 8.2 错误报告
- 详细的错误位置信息（行号）
- 清晰的错误描述
- 建议的修复方案
- 错误分类和严重程度

## 9. 扩展性设计

### 9.1 模块化设计
- 清晰的接口定义
- 松耦合的模块关系
- 可插拔的组件架构

### 9.2 扩展点
1. **新的属性类型**：支持更多属性类型
2. **优化算法**：替换核心算法实现
3. **输出格式**：支持多种输出格式
4. **可视化方式**：多种图形展示方式

## 10. 测试策略

### 10.1 测试覆盖
- 单元测试：核心算法和数据结构
- 集成测试：模块间交互
- 功能测试：完整功能流程
- 边界测试：极端情况处理

### 10.2 测试用例
- 正常情况：标准文法和输入
- 异常情况：错误文法和输入
- 边界情况：空输入、大规模输入
- 性能测试：大规模文法处理

**作者信息：**
- 姓名：王海翔
- 学号：2021060187
- 班级：计科2203
- 完成时间：2024年12月
