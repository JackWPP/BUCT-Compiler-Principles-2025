# LR语法分析方法判断程序测试用例

## 项目信息
- **课程**: 编译原理
- **作业**: 题目4.10 LR语法分析方法判断
- **作者**: 王海翔
- **学号**: 2021060187
- **班级**: 计科2203

## 测试目标

本测试文档包含多个测试用例，用于验证LR语法分析方法判断程序的正确性，涵盖：
- LR(0)文法测试
- SLR(1)文法测试
- LR(1)文法测试
- LALR(1)文法测试
- 冲突检测测试
- 边界情况测试

---

## 测试用例1：简单LR(0)文法

### 输入文法
```
S -> A B
A -> a
B -> b
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
这是一个最简单的LR(0)文法，没有任何冲突。

---

## 测试用例2：经典算术表达式文法（SLR(1)）

### 输入文法
```
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```

### 开始符号
```
E
```

### 预期结果
- **LR(0)**: ❌ 否（存在移进-归约冲突）
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: LR(0)状态中存在移进-归约冲突，但SLR(1)可以通过FOLLOW集合解决

### 说明
这是编译原理教材中的经典例子，展示了SLR(1)相对于LR(0)的优势。

---

## 测试用例3：需要LR(1)的文法

### 输入文法
```
S -> A a | b A c | d c | b d a
A -> d
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ❌ 否
- **SLR(1)**: ❌ 否
- **LR(1)**: ✅ 是
- **LALR(1)**: ❌ 否（可能存在冲突）
- **冲突**: SLR(1)无法解决的冲突，需要LR(1)的向前看符号

### 说明
这个文法展示了LR(1)相对于SLR(1)的必要性。

---

## 测试用例4：含空产生式的文法

### 输入文法
```
S -> A B
A -> a | ε
B -> b
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
测试程序对空产生式（ε）的处理能力。

---

## 测试用例5：归约-归约冲突

### 输入文法
```
S -> A a | B a
A -> c
B -> c
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ❌ 否（归约-归约冲突）
- **SLR(1)**: ❌ 否（FOLLOW集合相同）
- **LR(1)**: ❌ 否（向前看符号相同）
- **LALR(1)**: ❌ 否
- **冲突**: 存在归约-归约冲突

### 说明
这个文法展示了无法用任何LR方法解析的情况。

---

## 测试用例6：左递归文法

### 输入文法
```
A -> A a | b
```

### 开始符号
```
A
```

### 预期结果
- **LR(0)**: ❌ 否（移进-归约冲突）
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: LR(0)存在冲突，SLR(1)可解决

### 说明
测试左递归文法的处理。

---

## 测试用例7：右递归文法

### 输入文法
```
A -> a A | b
```

### 开始符号
```
A
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
右递归文法通常更容易被LR方法处理。

---

## 测试用例8：复杂表达式文法

### 输入文法
```
E -> E + T | E - T | T
T -> T * F | T / F | F
F -> ( E ) | id | num
```

### 开始符号
```
E
```

### 预期结果
- **LR(0)**: ❌ 否
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: LR(0)存在多个移进-归约冲突

### 说明
更复杂的算术表达式文法，包含加减乘除运算。

---

## 测试用例9：条件语句文法

### 输入文法
```
S -> if E then S else S | if E then S | a
E -> b
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ❌ 否
- **SLR(1)**: ❌ 否（悬空else问题）
- **LR(1)**: ✅ 是
- **LALR(1)**: ❌ 否
- **冲突**: 经典的悬空else问题

### 说明
展示编程语言中常见的悬空else问题。

---

## 测试用例10：多个非终结符的复杂文法

### 输入文法
```
S -> A B C
A -> a A | ε
B -> b B | ε
C -> c
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
测试多个非终结符和多个空产生式的处理。

---

## 测试用例11：单产生式文法

### 输入文法
```
S -> a
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
最简单的文法，只有一个产生式。

---

## 测试用例12：只有空产生式的文法

### 输入文法
```
S -> ε
```

### 开始符号
```
S
```

### 预期结果
- **LR(0)**: ✅ 是
- **SLR(1)**: ✅ 是
- **LR(1)**: ✅ 是
- **LALR(1)**: ✅ 是
- **冲突**: 无冲突

### 说明
边界情况：只包含空产生式的文法。

---

## 测试执行指南

### 1. 自动化测试
可以编写脚本批量执行这些测试用例：

```python
# 示例测试脚本
test_cases = [
    {
        "name": "测试用例1",
        "grammar": ["S -> A B", "A -> a", "B -> b"],
        "start": "S",
        "expected": {"LR0": True, "SLR1": True, "LR1": True, "LALR1": True}
    },
    # ... 更多测试用例
]

for test in test_cases:
    result = analyze_grammar(test["grammar"], test["start"])
    assert result == test["expected"], f"测试失败: {test['name']}"
```

### 2. 手动测试步骤
1. 启动程序：`python lr_parser_gui.py`
2. 在文法输入区域输入测试文法
3. 设置开始符号
4. 点击"执行LR分析"
5. 对比结果与预期
6. 检查冲突详情
7. 查看状态机可视化

### 3. 性能测试
- 测试大型文法的处理时间
- 测试内存使用情况
- 测试可视化渲染性能

### 4. 错误处理测试
- 输入格式错误的文法
- 输入不存在的开始符号
- 输入循环定义的文法
- 输入包含未定义符号的文法

---

## 预期输出格式

每个测试用例的输出应包含：

1. **文法信息**
   - 产生式列表
   - 终结符集合
   - 非终结符集合
   - 开始符号

2. **FIRST/FOLLOW集合**
   - 每个符号的FIRST集合
   - 每个非终结符的FOLLOW集合

3. **LR方法判断结果**
   - LR(0): 是/否
   - SLR(1): 是/否
   - LR(1): 是/否
   - LALR(1): 是/否

4. **冲突详情**
   - 冲突类型（移进-归约/归约-归约）
   - 冲突位置（状态编号）
   - 冲突符号

5. **自动机信息**
   - 状态数量
   - 转换数量
   - 项目集详情

---

## 测试验证标准

### 正确性验证
1. **理论验证**：结果应符合编译原理理论
2. **对比验证**：与教材例题对比
3. **交叉验证**：与其他LR分析工具对比

### 性能验证
1. **时间复杂度**：分析时间应在合理范围内
2. **空间复杂度**：内存使用应控制在合理范围
3. **可视化性能**：图形渲染应流畅

### 用户体验验证
1. **界面响应**：操作应有及时反馈
2. **错误提示**：错误信息应清晰明确
3. **结果展示**：结果应易于理解

---

## 测试报告模板

```
测试日期：____年____月____日
测试人员：________________
程序版本：________________

测试结果统计：
- 总测试用例数：12
- 通过用例数：____
- 失败用例数：____
- 通过率：____%

失败用例详情：
1. 用例名称：____________
   失败原因：____________
   预期结果：____________
   实际结果：____________

性能测试结果：
- 平均分析时间：____ms
- 最大内存使用：____MB
- 可视化渲染时间：____ms

建议和改进：
1. ________________________
2. ________________________
3. ________________________
```

---

## 注意事项

1. **符号约定**：确保终结符和非终结符的区分正确
2. **格式要求**：严格按照BNF格式输入文法
3. **编码问题**：注意中文字符的处理
4. **版本兼容**：确保Python和依赖库版本兼容
5. **环境配置**：确保matplotlib能正确显示中文

---

## 扩展测试

### 1. 压力测试
- 大规模文法（100+产生式）
- 深度递归文法
- 复杂状态机（1000+状态）

### 2. 边界测试
- 空文法
- 单符号文法
- 循环定义检测

### 3. 兼容性测试
- 不同操作系统
- 不同Python版本
- 不同依赖库版本

### 4. 用户场景测试
- 教学演示场景
- 作业提交场景
- 研究分析场景

通过这些全面的测试用例，可以确保LR语法分析方法判断程序的正确性、稳定性和实用性。